// --------------------------------------------------------------------------------------------
// The following code is automatically generated by the mongo-dao-generator tool.
// Please do not modify this code manually to avoid being overwritten in the next generation.
// For more tool details, please click the link to view https://github.com/dobyte/gorm-dao-generator
// --------------------------------------------------------------------------------------------

package internal

import (
	"context"
	"errors"
	"fmt"
	modelpkg "github.com/dobyte/gorm-dao-generator/example/model"
	"gorm.io/gorm"
)

type MailOrderBy struct {
	Column string
	Order  string
}

type MailFilterFunc func(cols *MailColumns) interface{}
type MailUpdateFunc func(cols *MailColumns) interface{}
type MailColumnFunc func(cols *MailColumns) []string
type MailOrderFunc func(cols *MailColumns) []MailOrderBy

type Mail struct {
	Columns   *MailColumns
	Database  *gorm.DB
	Table     *gorm.DB
	TableName string
}

type MailColumns struct {
	ID       string // 邮件ID
	Title    string // 邮件标题
	Content  string // 邮件内容
	Sender   string // 邮件发送者
	Receiver string // 邮件接受者
	Status   string // 邮件状态
	SendTime string // 发送时间
}

var mailColumns = &MailColumns{
	ID:       "id",        // 邮件ID
	Title:    "title",     // 邮件标题
	Content:  "content",   // 邮件内容
	Sender:   "sender",    // 邮件发送者
	Receiver: "receiver",  // 邮件接受者
	Status:   "status",    // 邮件状态
	SendTime: "send_time", // 发送时间
}

func NewMail(db *gorm.DB) *Mail {
	dao := &Mail{}
	dao.Columns = mailColumns
	dao.TableName = "mail"
	dao.Database = db
	dao.Table = db.Table(dao.TableName)

	return dao
}

// Insert executes an insert command to insert multiple documents into the collection.
func (dao *Mail) Insert(ctx context.Context, models ...*modelpkg.Mail) (int64, error) {
	if len(models) == 0 {
		return 0, errors.New("models is empty")
	}

	var rst *gorm.DB

	if len(models) == 1 {
		rst = dao.Table.WithContext(ctx).Create(models[0])
	} else {
		rst = dao.Table.WithContext(ctx).Create(models)
	}

	return rst.RowsAffected, rst.Error
}

// Delete executes a delete command to delete at most one document from the collection.
func (dao *Mail) Delete(ctx context.Context, filterFunc MailFilterFunc) (int64, error) {
	db := dao.Table.WithContext(ctx)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	rst := db.Delete(&modelpkg.Mail{})

	return rst.RowsAffected, rst.Error
}

// Update executes an update command to update documents in the collection.
func (dao *Mail) Update(ctx context.Context, filterFunc MailFilterFunc, updateFunc MailUpdateFunc) (int64, error) {
	db := dao.Table.WithContext(ctx)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if updateFunc != nil {
		rst := db.Updates(updateFunc(dao.Columns))

		return rst.RowsAffected, rst.Error
	}

	return 0, nil
}

// Count returns the number of documents in the collection.
func (dao *Mail) Count(ctx context.Context, filterFunc MailFilterFunc) (count int64, err error) {
	db := dao.Table.WithContext(ctx)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	err = db.Count(&count).Error

	return
}

// First executes a first command and returns a model for one record in the table.
func (dao *Mail) First(ctx context.Context, filterFunc MailFilterFunc, columnFunc ...MailColumnFunc) (*modelpkg.Mail, error) {
	var (
		model = &modelpkg.Mail{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.First(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// Last executes a last command and returns a model for one record in the table.
func (dao *Mail) Last(ctx context.Context, filterFunc MailFilterFunc, columnFunc ...MailColumnFunc) (*modelpkg.Mail, error) {
	var (
		model = &modelpkg.Mail{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Last(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindOne executes a take command and returns a model for one record in the table.
func (dao *Mail) FindOne(ctx context.Context, filterFunc MailFilterFunc, columnFunc ...MailColumnFunc) (*modelpkg.Mail, error) {
	var (
		model = &modelpkg.Mail{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Take(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindMany executes a find command and returns many models the matching documents in the collection.
func (dao *Mail) FindMany(ctx context.Context, filterFunc MailFilterFunc, columnFunc MailColumnFunc, orderFunc MailOrderFunc, limitAndOffset ...int) ([]*modelpkg.Mail, error) {
	var (
		models = make([]*modelpkg.Mail, 0)
		db     = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if columnFunc != nil {
		columns := columnFunc(dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if orderFunc != nil {
		orders := orderFunc(dao.Columns)

		for _, order := range orders {
			db = db.Order(fmt.Sprintf("%s %s", order.Column, order.Order))
		}
	}

	if len(limitAndOffset) > 0 {
		db = db.Limit(limitAndOffset[0])
	}

	if len(limitAndOffset) > 1 {
		db = db.Offset(limitAndOffset[1])
	}

	rst := db.Scan(&models)

	if rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return models, nil
}
