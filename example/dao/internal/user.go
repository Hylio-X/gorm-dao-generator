// --------------------------------------------------------------------------------------------
// The following code is automatically generated by the mongo-dao-generator tool.
// Please do not modify this code manually to avoid being overwritten in the next generation. 
// For more tool details, please click the link to view https://github.com/dobyte/gorm-dao-generator
// --------------------------------------------------------------------------------------------

package internal

import (
	"context"
	"errors"
	"fmt"
	modelpkg "github.com/dobyte/gorm-dao-generator/example/model"
	"gorm.io/gorm"
	"strconv"
	"strings"
)

type UserOrderBy struct {
	Column string	
	Order  string
}

type UserFilterFunc func(cols *UserColumns) interface{}
type UserUpdateFunc func(cols *UserColumns) interface{}
type UserColumnFunc func(cols *UserColumns) []string
type UserOrderFunc func(cols *UserColumns) []UserOrderBy

type User struct {
	Columns   *UserColumns
	Database  *gorm.DB
	TableName string
}

type UserColumns struct {
	ID             string 
	UID            string // 用户ID
	Account        string // 用户账号
	Password       string // 用户密码
	Salt           string // 密码
	Mobile         string // 用户手机
	Email          string // 用户邮箱
	Nickname       string // 用户昵称
	Signature      string // 用户签名
	Gender         string // 用户性别
	Level          string // 用户等级
	Experience     string // 用户经验
	Coin           string // 用户金币
	Type           string // 用户类型
	Status         string // 用户状态
	DeviceID       string // 设备ID
	ThirdPlatforms string // 第三方平台
	RegisterIP     string // 注册IP
	RegisterTime   string // 注册时间
	LastLoginIP    string // 最近登录IP
	LastLoginTime  string // 最近登录时间
}

var userColumns = &UserColumns{
	ID:             "id",              
	UID:            "uid",             // 用户ID
	Account:        "account",         // 用户账号
	Password:       "password",        // 用户密码
	Salt:           "salt",            // 密码
	Mobile:         "mobile",          // 用户手机
	Email:          "email",           // 用户邮箱
	Nickname:       "nickname",        // 用户昵称
	Signature:      "signature",       // 用户签名
	Gender:         "gender",          // 用户性别
	Level:          "level",           // 用户等级
	Experience:     "experience",      // 用户经验
	Coin:           "coin",            // 用户金币
	Type:           "type",            // 用户类型
	Status:         "status",          // 用户状态
	DeviceID:       "device_id",       // 设备ID
	ThirdPlatforms: "third_platforms", // 第三方平台
	RegisterIP:     "register_ip",     // 注册IP
	RegisterTime:   "register_time",   // 注册时间
	LastLoginIP:    "last_login_ip",   // 最近登录IP
	LastLoginTime:  "last_login_time", // 最近登录时间
}

func NewUser(db *gorm.DB) *User {
	dao := &User{}
	dao.Columns = userColumns
	dao.TableName = "user"
	dao.Database = db

	return dao
}

// New create a new instance and return
func (dao *User) New(tx *gorm.DB) *User {
	d := &User{}
	d.Columns = dao.Columns
	d.TableName = dao.TableName
	d.Database = tx

	return d
}

// Table create a new table db instance
func (dao *User) Table(ctx context.Context) *gorm.DB {
	return dao.Database.Model(&modelpkg.User{}).Table(dao.TableName).WithContext(ctx)
}

// Insert executes an insert command to insert multiple documents into the collection.
func (dao *User) Insert(ctx context.Context, models ...*modelpkg.User) (int64, error) {
	if len(models) == 0 {
		return 0, errors.New("models is empty")
	}

	var rst *gorm.DB

	if len(models) == 1 {
		rst = dao.Table(ctx).Create(models[0])
	} else {
		rst = dao.Table(ctx).Create(models)
	}

	return rst.RowsAffected, rst.Error
}

// Delete executes a delete command to delete at most one document from the collection.
func (dao *User) Delete(ctx context.Context, filterFunc ...UserFilterFunc) (int64, error) {
	db := dao.Table(ctx)

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := db.Delete(&modelpkg.User{})

	return rst.RowsAffected, rst.Error
}

// Update executes an update command to update documents in the collection.
func (dao *User) Update(ctx context.Context, filterFunc UserFilterFunc, updateFunc UserUpdateFunc, columnFunc ...UserColumnFunc) (int64, error) {
	db := dao.Table(ctx)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		db = db.Select(columnFunc[0](dao.Columns))
	}

	if updateFunc != nil {
		rst := db.Updates(updateFunc(dao.Columns))

		return rst.RowsAffected, rst.Error
	}

	return 0, nil
}

// Count returns the number of documents in the collection.
func (dao *User) Count(ctx context.Context, filterFunc ...UserFilterFunc) (count int64, err error) {
    db := dao.Table(ctx)

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	err = db.Count(&count).Error

	return
}

// Sum returns the sum of the given field.
func (dao *User) Sum(ctx context.Context, columnFunc UserColumnFunc, filterFunc ...UserFilterFunc) (sums []float64, err error) {
	columns := columnFunc(dao.Columns)
	if len(columns) == 0 {
		return
	}

	fields := make([]string, len(columns))
	for i, column := range columns {
		fields[i] = fmt.Sprintf("COALESCE(SUM(%s), 0) as `sum_%d`", column, i)
	}

	db := dao.Table(ctx).Select(strings.Join(fields, ","))

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := make(map[string]interface{}, len(columns))

	if err = db.Scan(&rst).Error; err != nil {
		return
	}

	for i := range columns {
		val, _ := rst[fmt.Sprintf("sum_%d", i)]
		sum, _ := strconv.ParseFloat(val.(string), 64)
		sums = append(sums, sum)
	}

	return
}

// Avg returns the avg of the given field.
func (dao *User) Avg(ctx context.Context, columnFunc UserColumnFunc, filterFunc ...UserFilterFunc) (avgs []float64, err error) {
	columns := columnFunc(dao.Columns)
	if len(columns) == 0 {
		return
	}

	fields := make([]string, len(columns))
	for i, column := range columns {
		fields[i] = fmt.Sprintf("COALESCE(AVG(%s), 0) as `avg_%d`", column, i)
	}

	db := dao.Table(ctx).Select(strings.Join(fields, ","))

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := make(map[string]interface{}, len(columns))

	if err = db.Scan(&rst).Error; err != nil {
		return
	}

	for i := range columns {
		val, _ := rst[fmt.Sprintf("avg_%d", i)]
		avg, _ := strconv.ParseFloat(val.(string), 64)
		avgs = append(avgs, avg)
	}

	return
}

// First executes a first command and returns a model for one record in the table.
func (dao *User) First(ctx context.Context, filterFunc UserFilterFunc, columnFunc ...UserColumnFunc) (*modelpkg.User, error) {
	var (
		model = &modelpkg.User{}
		db    = dao.Table(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.First(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// Last executes a last command and returns a model for one record in the table.
func (dao *User) Last(ctx context.Context, filterFunc UserFilterFunc, columnFunc ...UserColumnFunc) (*modelpkg.User, error) {
	var (
		model = &modelpkg.User{}
		db    = dao.Table(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Last(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindOne executes a take command and returns a model for one record in the table.
func (dao *User) FindOne(ctx context.Context, filterFunc UserFilterFunc, columnFunc ...UserColumnFunc) (*modelpkg.User, error) {
	var (
		model = &modelpkg.User{}
		db    = dao.Table(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Take(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindMany executes a find command and returns many models the matching documents in the collection.
func (dao *User) FindMany(ctx context.Context, filterFunc UserFilterFunc, columnFunc UserColumnFunc, orderFunc UserOrderFunc, limitAndOffset ...int) ([]*modelpkg.User, error) {
	var (
		models = make([]*modelpkg.User, 0)
		db     = dao.Table(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if columnFunc != nil {
		columns := columnFunc(dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if orderFunc != nil {
		orders := orderFunc(dao.Columns)

		for _, order := range orders {
			db = db.Order(fmt.Sprintf("%s %s", order.Column, order.Order))
		}
	}

	if len(limitAndOffset) > 0 {
		db = db.Limit(limitAndOffset[0])
	}

	if len(limitAndOffset) > 1 {
		db = db.Offset(limitAndOffset[1])
	}

	rst := db.Scan(&models)

	if rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return models, nil
}
